# 1.HTTP vs HTTPS

![image](https://user-images.githubusercontent.com/75282888/118450602-560d7300-b72f-11eb-87e9-83035068843a.png)

과거(대략 14년도 이전)에는 신용카드 번호와 같은 매우 예민한 정보를 다루는 이커머스사업자가 아닌 이상 굳이 HTTPS를 사용하지 않았다고 한다. 하지만 구글에서 HTTPS로의 전환을 권고했고, HTTPS로 전환하는 사이트에게 **검색 노출 가산점**을 부여한다고 발표하자. 이에 따라 수많은 사이트들이 본격적으로 HTTPS로 전환하기 시작했다.



## 1.1. HTTP

![image](https://user-images.githubusercontent.com/75282888/118451460-3f1b5080-b730-11eb-8ff7-ae99b3060281.png)

0. Hypertext Transfer Protocol의 약자이다. 
1. **HTML을 주고 받기 위한 통신규약**(Protocol) 정도로 이해하면 좋을 것 같다.
2. HTTP를 통해 전송되는 **데이터에 암호화가 걸려있지 않다**는 치명적인 문제점을 갖고 있다.
3. 즉 정보가 해킹되기 쉽다는 얘기다.



## 1.2. HTTPS![image](https://user-images.githubusercontent.com/75282888/118451119-de8c1380-b72f-11eb-82d2-fe489a3b2384.png)
0. Hypertext Transfer Protocol Secure의 약자이다.
1.  HTTP의 보안 문제를 해결하기 위해  HTTPS로 전송되는 데이터에는 **암호화**가 걸려있다.
2. 이와 같은 데이터 암호화를 위해 **SSL**이라는 방식을 사용한다.







# 2. 사전 지식들

#### SSL을 이해하기 앞서

> - 우선 **대칭키 암호화**와 **공개키 암호화**를 이해해야 한다.
> 
> - SSL 통신에서 이 두가지 암호화 방식이 사용되기 때문이다.



## 2.1.대칭키 암호화란?

![image](https://user-images.githubusercontent.com/75282888/119214049-b8cf8780-bafe-11eb-8fe1-34d1d500f11d.png)

암호화에 사용되는 Key와 복호화에 사용되는 Key가 동일한 암호화 방식이다.

대칭키 방식에서는 "홍규"라는 문자열을 <u>"바보"라는 Key로 **암호화**했다면 "바보"라는 Key로 **복호화** 할 수 있다.</u>

(참고로 암호화한 자료를 원상 복구시키는 것을 복호화라고 한다.)



## 2.2. 공개키 암호화란?

![image](https://user-images.githubusercontent.com/75282888/119214144-6f336c80-baff-11eb-8395-164f8ba0e8be.png)

- 공개키 암호화 방식에서는 **'공개키'**와 **'개인키'**라는 **두가지 상호적인 Key**가 있습니다.
- 만약 공개키로 암호화 했다면 개인키로만 복호화 할 수 있고, 개인키로 암호화 했다면 공개키로만 복호화 할 수 있습니다.

![image](https://user-images.githubusercontent.com/75282888/119218123-b0387a80-bb19-11eb-8b24-9cc777049cea.png)







# 3. SSL 인증서의 이해

## 3.1. SSL 인증서의 역할

0. SSL 인증서는 클라이언트와 서버 사이의 통신을 **제3자(CA, Certificate Authority)가 보증해주는 전자화 된 문서**이다.

1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 쉽게 얘기하면 내가 접속한 사이트가 해커들이 만든 피싱사이트가 아님을 보장한다는 이야기다. 
2. SSL 통신에 사용할 <u>서버측이 제공하는 공개키를 클라이언트에게 제공한다.</u>  브라우저의 내장된 CA의 공개키와 구분해야 한다.



## 3.2. CA와 SSL 인증서

- SSL을 통해 암호화된 통신을 제공하기 위해서는 **CA를 통해서 인증서를 구입해야 한다.** 
- CA는 엄격한 검증을 걸쳐 해당 서비스가 신뢰할 수 있는 서비스라고 판단되면, 해당 서비스의 신뢰성을 보증하는 **SSL 인증서**를 발급해준다.
- SSL인증서는 **공개키 암호화**가 사용된다. SSL인증서는 CA의 개인키(Private Key)를 통해서 암호화되며, 이를 복호화하기 위한 **공개키는 브라우저에 내장되어 있다.**  

- 사적인 목적으로 SSL의 암호화 기능을 이용하려 한다면 자신이 직접 CA의 역할을 할 수도 있다. 공인된 인증서가 아니기에 브라우저 상 경고가 나온다.

## 3.3. SSL 인증서의 내용

- 인증서가 보증하고자 하는 서비스의 정보 (대표적으로 해당 서비스의 서버 **도메인** )

- SSL 인증서를 발급한 CA 이름.

- SSL통신에 사용될 **서버 측이 제공하는 공개키** (앞서 SSL인증서를 복호화 할 떄 사용하는 브라우저에 내장된 CA의 공개키와 구분해야 한다.)



서비스의 도메인, SSL통신에 사용할 공개키와 같은 정보는 (SSL을 이용하고자 하는) 서비스가 CA로부터 인증서를 구입할 때 제출해야 한다. 



## 3.4. SSL인증서는 어떻게 서비스를 보증하나? 어떻게 서버의 신뢰성을 보증하나?

- 브라우저가 서버에 접속할 떄 서버는 **제일 먼저 인증서를 제공한다.**

- 브라우저는 서버로부터 받은 인증서가 브라우저 안에 내장된 CA 리스트에 있는지를 확인한다.

- 확인 결과 서버를 통해 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 **해당 CA의 공개키**(역시 브라우저에 내장되어 있음)를 이용해서 인증서를 복호화 한다.

- 서버로부터 받은 인증서가 브라우저에 내장된 CA의 공개키로 복호화 할 수 있다는 것은 해당 인증서가 CA의 비공개키를 통해 암호화 된 것을 의미한다. 즉 서버가 제공한 인증서는 CA에 의해서 발급된 **진짜 인증서**라는 이야기다.

- 그리고 CA에서 인증서를 발급해줬다는 것은 해당 서비스가 CA의 검증을 통과한 믿을만한 서비스라는 이야기이기도 하다.

- 이것이 바로 CA와 브라우저가 특정 서버를 인증하는 과정이다.





## 3.5. SSL의 동작 방법



지금까지 CA의 공개키와 SSL인증서를 통해 서비스와 서버의 안전을 보장하는 방법에 대해 알아봤다.

그렇다면 **SSL 인증서에 포함된 서비스의 공개키**는 어떤 용도로 사용되나?



SSL은 암호화된 데이터를 전송하기 위해 대칭키와 공개키를 혼합해서 사용한다.

실제 데이터는 대칭키로 암호화하고, 그리고 해당 **<u>대칭키의 Key를 공개키로 암호화</u>**한다.







# 4. SSL의 통신 과정

 ![image](https://user-images.githubusercontent.com/75282888/119218077-5fc11d00-bb19-11eb-81b4-e9a41ee4b4b6.png)
- SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다.
- 클라이언트와 서버가 주고 받는 <u>**실제 정보**는 대칭키 방식으로 암호화</u>하고, 
- 대칭키 방식으로 암호화된 실제 정보를 <u>복호화할 때사용할 대칭키는 **공개키 방식**으로 암호화</u>해서 클라이언트와 서버가 주고 받는다. 



컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 **3가지 단계**가 있다. 아래와 같다.

> **악수 -> 전송 -> 세션종료**

이것은 은밀하게 일어나기 때문에 사용자에게 노출되지 않는다. 이 과정에서 SSL가 어떻게 데이터를 암호화해서 전달하는지 살펴보자.



### 4.1. 악수 (handshake)

1. 클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.

   - 클라이언트 측에서 생성한 랜덤 데이터 
   - 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
   - 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 [기존의 세션](https://opentutorials.org/course/228/4894#session)을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.
   
2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.

   - 서버 측에서 생성한 랜덤 데이터 
   - 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
   - **인증서**

3. 

   - 클라이언트는 서버의 인증서(Server Hello 때 받은 ) 가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. 
   - CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 
   - 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 
   - 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다. 
   - 클라이언트는 상기 2번을 통해서 받은 <u>서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 **pre master secret**</u>라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 이 때 사용할 암호화 기법은 대칭키이기 때문에 **pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.**

   - (Server Hello를 통해 받은 인증서 안에 담겨 있는) **서버의 공개키**로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 즉, 안전하게 pre master secret을 서버와 클라이언트가 공유할 수 있다.
   
4. 

   - 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 
   - 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 
   - 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억하자.
   
5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

   

### 2. 세션

- 세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 

- 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 **session key** 값을 이용해서 **대칭키 방식으로** 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.

  

> 그냥 공개키를 사용하면 될 것을 대칭키와 공개키를 조합해서 사용하는 이유는 무엇을까? 그것은 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문이다. 만약 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 할 것이다. 반대로 대칭키는 암호를 푸는 열쇠인 대칭키를 상대에게 전송해야 하는데, 암호화가 되지 않은 인터넷을 통해서 키를 전송하는 것은 위험하기 때문이다. 그래서 속도는 느리지만 데이터를 안전하게 주고 받을 수 있는 공개키 방식으로 대칭키를 암호화하고, 실제 데이터를 주고 받을 때는 대칭키를 이용해서 데이터를 주고 받는 것이다.



### 3. 세션종료

데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.









https://opentutorials.org/course/228/4894

https://seopressor.com/blog/http-vs-https/
https://medium.com/@audira98/http-vs-cheap-https-vs-expensive-https-e3b611f07dd2
